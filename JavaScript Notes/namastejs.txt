https://www.youtube.com/watch?v=ZvbzSrg0afE&list=PLlasXeu85E9cQ32gLCvAvr9vNaUccPVNP&index=2&ab_channel=AkshaySaini

1. JS in the backend : Javascript is a synchrounous single-threaded language

(variable
enviroment)
Memory       |        Code 
key:value    |        thread of execution
fn: {}


2. What happens when you run js Code

drawiofile.
Call stack manages execution content in JS. EC has memory and code execution. Thats it
Call stack maintains the order of execution context:


3. Hoisting in JS
    - Functions are hoisted but not variables
    - functions and variables are stored in memory before execution so logging a variable before it is assigned will be undefined instead of error not found.
    

4. Functions: Understand execution context and call stack with the code below:

    var x = 1;
    a();
    b();
    console.log(x);

    function a(){
        var x = 10;
        console.log(x);
    }

    function b(){
        var x = 100;
        console.log(x);
    }


5. Shortest JS program:

    - an empty file because JS engine is still doing things behind the scenes.
    - JS creates a window even with a empty js file. 
        - window is a global object which is created along with the global execution context.
        - you can access any of the methods and vars anywhere in our js enviroment since it is global. 

    this  === window object

    - global space is just any variable or function  that is not inside a function.



7. Scope Chain

    function  a(){
        var b = 10;
        c();
        function c(){
            //c function is lexcically sitting inside a function
            console.log(b) // there is no b in c function memory so it goes to lexical enviroment of a. A has b so it will reference that b. 
        }
    }

    a();
    console.log(b) // error

    - whenever a execution context is created, a lexical environment is created. 

    - lexical environment is a collection of variables and functions that are scoped to a particular block of code.
    - lexical memory reference to parent environment which is just memory space but also to parent's parent. 
    - scope chain is a collection of lexical environments.


8. Let & const, temperal deadzones

    - let & const are hoisted very differently than var. let & const are stored in temporal deadzone
     
    console.log(b); // undefined (because of hoisting)
    console.log(a); // ERROR: (because of hoisting)

    let a = 10;
    var b = 100;

    JS has allocated memory to both a & b but the let a was allocated to a different memory space from global. You cannot access let & const memory until you have assigned a value to them.
    - temporal deadzone is a concept that JS engine uses to prevent access to variables that are not yet assigned. so its the time of when let was scanned and memory was allocated but until the point it gets assigned a value.
    - let & const are more strict than var. there will be no code execution until the syntax error is fixed. 
    - let vs const
        - cannot overide const 
        - syntax error for const is when a value is not assigned to const, but let allows us to just initialize 
        - let&const and cannot create duplicate variables


9. Block - Scope 



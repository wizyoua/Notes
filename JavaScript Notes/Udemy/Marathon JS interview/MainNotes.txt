https://www.udemy.com/course/javascript-marathon-interview-questions-series/learn/lecture/19742598?start=0#overview

1. Language Fundamentals
    - difference between null and undefined
        - undefined: before any value is assigned to a variable the variable contains undefined, it is also a data type
        - null: means nothing, both undefined andnull mean nothingness but they both are different data types, so undefined == null is true 
          but undefined === null is false

        - you can assign a variable to undefined
    
    - function scope vs block scope
        - es5 has function scope because of hoisting and es6 has block scope
            - var keyword is hoisted but let and const are hoisted to their block
        - es6 has block scope
            - let and const are hoisted to their block

    - Automatic semicolon insertion
        - javascript automatically inserts semicolons at the end of a line if it is missing.

    - Rest vs Spread
        - rest: used to pass an indefinite number of arguments to a function
        - should always be in the last parameter of a function

        // non arrow function can also just log arguments which is an object that contains all the arguments passed to the function
        function sum(...args){
            console.log(args);
        }
        sum(1,2,3)


        - spread: used to split up array elements or object properties
        let arr1 = [1,2,3];
        let arr2 = [...arr1,4,5,6];
    
    -infinity vs -infinity as output
        -infinity: highest value possible in javascript (Positive Infinity)
        - infinity: lowest value possible in javascript (Negative Infinity)

        console.log(Number.POSITIVE_INFINITY); // Infinity
        - value is larger than 64 bit format, in that case it is infinity or -infinity

        console.log(9e4) // 90000 e4 adds 4 zeros to the end of the number

        Number.MAX_VALUE // 1.7976931348623157e+308
        -Number.MIN_VALUE // 5e-324

        console.log(1/0); // Infinity why? because 1/0 is 1 divided by 0 which is infinity

    - NaN
        - global property representing Not-A-Number value
        - isNan() // checks if value is number or not
        - always use isNan() instead of === NaN because NaN is not equal to itself

        - isFinite() // checks if value is finite or not
            - console.log(isFinite(Infinity)); // false
            - console.log(isFinite(5*4)) // true
        - if we expect certain values from a function but can also be NaN then we can use isFinite() to check if the value is finite or not

    - Arrow functions
        - "this" does not work in arrow functions. a this is not the function scope but the global scope. why? arrow function doesn't behave like a class.
        - arguments object does not work in arrow functions
            function test(){
                console.log(arguments);
            } // will work
            let test = () => {
                console.log(arguments);
            } // will not work, but the rest operator will work, which will put the args into an array

        - we cannot use new keyword with arrow functions


        Major point is that traditional functions act like classes but arrow functions do not. 
        also there is Class in es6 which is a new way of creating objects

    - How does a closure work
        - a closure is a function that has access to the parent scope even after the parent function has closed

        function outer(){
            let a = 10;
            function inner(){
                console.log(a);
            }
            return inner;
        }

        let innerFunc = outer(); //the inner function is returned and assigned to innerFunc
        innerFunc(); // 10 - now we can call the inner function even after the outer function has closed

        es6:
        const outer = () => {
            let a = 10;
            return () => {
                console.log('inner called with parent scope a = ' + a);
            }
        }

        const cl = outer();
        cl();

        [[enviroment]] is where the closure variables are stored

        - when we use a closrue we are making private members globally
        - main advantafe of closures is that we can create private members and can keep track of the state of the function

    - How can sum(5)(6) return 11
        - function currying
        - function currying is a technique of evaluating function with multiple arguments, into sequence of functions with single argument

        const sum = function(a){
            return function(b){
                return a + b;
            }
        }
        const cl = sum(5); // the 5 is passed to a, now cl has reference to the inner function
        const ans = cl(6); // the 6 is passed to b, now ans has the value of 11

        sum(5)(6) // 11 - this is the same as above, but we are calling the function directly. The first parent function is called, stored in lexical enviroment 
        and then the inner function is called. basically like parent and child function chaining

        es6 version with arrow functions:
        const sum = a => b => a + b;
        const newAns = sum(5)(6) // 11
        
        -when we see 2 arrows in a row, we know that it is a curried function, they are the inner functions
        -what is the practical use of this?

        const priceCalc = (price) =>{
            return (dper)=>{
                return price * dper;
            }
        }
        
        const newPrice = priceCalc(100); // we are calling the function partially
        console.log(newPrice(0.1)); // 10% off

        - the principle is we can partially call a function and have a constant val state, then work on that 
        data after
        - helps avoid unwanted repition of code

    - Iterables and iterators 
        let arr = [1,2,3];
        let iter = arr[Symbol.iterator](); // this is the iterator
        console.log(iter.next()); // {value: 1, done: false} - done is false because there are more values to iterate through, this is awesome because in a way, we can solve unique problems with this.

        - look how we can iterate through an object with a for of loop
        const obj {
            start: 10,
            end: 15,
            [Symbol.iterator](){
                return {
                    next(){
                        if(obj.start <= obj.end){
                            return {value:obj.start++, done:false}
                        }else {
                            return {done:true}
                        }
                    }
                }
            }
        }

        for(let i of obj) {
            console.log(i);
        }

        - limitation is only possible when iterator or iterable are the same object
        - also cannot another for of loop at the same time because the iterator is already being used

        - purpose of iterator: make a data structure iterable which is not 
        - use case: custom data structure used by other developers, we are in a way creating a pointer to iterate through the data structure that you provided.

    - Generators
        - help you pause and resume a function
        - generators are functions that can return multiple values in phases

        const getFunction = function* (){
            console.log('hello')
            yield "can return any value as well"; // function will pause, the return will be hello + {value: "can return any value as well", done: false}
            console.log('world');
            yield; // function will pause
            console.log('end');
        }

        const genObj = getFunction(); // we get a generator object
        console.log(genObj) // Object [Generator] {}
        genObj.next(); // hello

        - we can use generators to create iterators
        const obj = [...getFunction()]; // we can use spread operator to get the values from the generator
        for(let o of gObj){
            console.log(o);
        }

        -generators work well with iterators
        - yield will always be the return value of the generator function, can't use outside of generator function
        - return & throw methods are also available in generators
        - they are used in async processes

    
    - Memory Management and Garbage Collection
        - JS is a high level language automatically managing Memory
        - garbage collection considers references and tries to release the memory if location is not reachable
        - Mark and sweep algo starts from the root object and checks for the references linked
        - older browsers have a problem with memory leaks, but newer browsers don't. circular references are the main cause of memory leaks

    - Error handling in javascript
        - no error at compile but at run use a a try catch block
        try {
            // code
        } catch (error) {
            // code
        }

        //there is a finally block as well that executes after the code
        // wether there is an error or not, but for the most part in newer TS versions we don't need it
        finally {
            // code
        }
        - throw a custom error
        throw new Error('error message');

Section 2: 
    Explain Array & traversal in array
        - array stores data in a linear fashion
        - starts at 0 index
        - has arr.length or arr.length - 1 for the last index

    es6 we have:
    - for in (not recommended for array iteration)
        - for in is used to iterate over the properties of an object
        - if we use it with array it will return the index of the array
    
    - for of
        - for of is used to iterate over the values of an iterable object like an array
        - if we use it with an array it will return the value of the array
    
    - forEach
        - arr.forEach((el, idx) => {
            console.log(el);
            console.log(idx);
        })
    
    Adding and removing elements from array
        - push - add to the end of the array
            : arr.push(4);
        - pop - remove from the end of the array
            : arr.pop(); // returns the value that was removed from end end of the array
        - shift - remove from the beginning of the array
            : arr.shift(); // returns the value that was removed from the beginning of the array
        - unshift - add to the beginning of the array
            : arr.unshift(0); // adds 0 to the beginning of the array
        - splice - add or remove from any position in the array
            : (start, deleteCount, valueAdded or Replaced)
        - slice - copy a portion of the array
            : (start, end)

    Performing Search in array
        testArr = [1,2,3,2,1];
        - indexOf - returns the index of the first occurence of the value
            : arr.indexOf(2); // returns 1
        - lastIndexOf - returns the index of the last occurence of the value
            : arr.lastIndexOf(2); // returns 3
        - includes - returns true or false if the value is in the array

        testArr = [1000, 2000, 3000, 4000, 5000];
        - find - returns the first value that satisfies the condition
            : arr.find((el) => el > 3000); // returns 4000
            : arr.find((el, idx) => idx > 2); // returns 4000
            : arr.find((el, idx, arr) => el > )
        - findIndex - returns the index of the first value that satisfies the condition
            : arr.findIndex((el) => el > 3000); // returns 3

         if no index is found, findIndex & find returns -1

        - filter - returns an array of all the values that satisfies the condition
            : arr.filter((el) => el > 3000); // returns [4000, 5000]

    What is the use of Map() method, is a must know 
        testArr = [1,2,3,4,5];
        arr.map((el, idx, arr) => console.log(el, idx)) // logs 1 0, 2 1, 3 2, 4 3, 5 4
        arr.map((el) => {
            el * el; // returns a new array with the values squared
        }) // returns [1,4,9,16,25] this returns a NEW array doesn't mutate the original array
    
    Flattening an array, using reduce method 
        - reduce() method executes a reducer function on each el, keeping track of the accumulator at eac elements
        iteration, then returns the accumulator. So it ended up giving us a single value from an array of values

        const arr = [1,2,3,4,5];
        const res = arr.reduce((acc, el) => {
            return acc + el;
        }, 0) // 15 this is the sum of all the elements in the array
        - notice the second parameter is the initial value of the accumulator, if we don't provide it, the first element of the array will be the initial value of the accumulator

        - to flatten a 2 dimensional array, we can use reduce method
        const arr = [[1,2,3], [4,5,6], [7,8,9]];
        const res = arr.reduce((acc, el) => {
            return acc.concat(el); // concat is appending the elements of the array to the accumulator
        }, []) // [1,2,3,4,5,6,7,8,9]

        - get sum of key fields in an array of objects
        const arr = [
            {name: 'john', age: 20},
            {name: 'jane', age: 30},
            {name: 'joe', age: 40}
        ]

        let totalSumAge = arr.reduce((acc, curr) => {
            return acc + curr.age
        }, 0)

        - reduce loops from left to right, reduceRight starts from right to left

    
    How can we sort an array
    - sort() but there is a better way using compare function
    - arr.sort((a,b) => a - b) // ascending order
    - arr.sort((a,b) => b - a) // descending order
    - if there is no compare function sort() will convert the elements to strings and sort them alphabetically

    Array Destructuring: 
    - const arr = [1,2,3,4,5];
    - const [a,b] = arr; // a = 1, b = 2
    flip values: [a,b] = [b,a] // a = 2, b = 1

    put variables in square brackets on left side of the assignment operator that means Destructuring
    -destructing is about extracting values from arrays or objects and assigning them to variables


Section 3: strings  
    1. String Basics
        - "" or '' or `` (template literals)
        - "have single quotes ' inside double quotes"
        - ' I \'m a single quote inside a single quote' - not a good practice
        - \u - allows us to use unicode characters. lets show a copy sign in the console
            "\u00A9" = ©
            "\u{1F60D}" = 😍 - use curly brackets when using more than 4 digits
        - \n - new line

    2. es6 template literals
        - `` - allows us to variables inside the string
        const name = 'john';
        console.log(`Hello ${name}`); // Hello john
        - `` - allows us to use multiline strings
        `hello this is line 1
        this is line 2 and so on`
    
    3. length property and search methods of strings
        - built in primitive types when compiled have access to object methods
        - search() can use regex but it does not have a starting index parameter
          unlike indexOf() and lastIndexOf() that have that optional parameter but they cannot
          use regex
        - length property - returns the length of the string
        - indexOf - returns the index of the first occurence of the value
        - lastIndexOf - returns the index of the last occurence of the value
        - includes - returns true or false if the value is in the string
        - startsWith - returns true or false if the string starts with the value
        - endsWith - returns true or false if the string ends with the value

    4. Extraction methods
       - String extraction methods:
            1.slice(startIdx, optionalIdx) - shallow copy of the string, you can use minus indexes
            and it will start from the end of the string like if it wraps around
            2.substring(startIdx, endIdx) - cannot take negative indexes, but it is pretty much same as slice 
            3.substr(startIdx, charsToTake) - takes the number of characters to take 
            4. charAt(idx) - returns the character at the index, if no idx is provided it will return the first character
            5. charCodeAt(idx) - returns the unicode value of the character at the index
    
    5. Case Conversion & replace method
        - str.toUpperCase() - converts the string to uppercase
        - str.toLowerCase() - converts the string to lowercase
        - str.replace('a', 'b') - replaces the first occurence of the value with the second value

Section 4: Date & time
    1. Date & time Basics
        - new Date() - creates a new date object
        - new Date(year, month, day, hours, minutes, seconds, milliseconds) - creates a new date object
        - parameters are 0 based for the month, so january is 0, february is 1, etc
        ISO 8601 - YYYY-MM-DDTHH:mm:ss.sssZ

    2. Date Methods:
        Get:
        - getFullYear() - returns the year
        - getMonth() - returns the month (0 based) 0 - 11
        - getDate() - returns the day of the month 1 - 31
        - getDay() - returns the day of the week 0 - 6

        Set:
        -setFullYear(year, [month], [day]) - sets the year
        -setMonth(month, [day] ) - sets the month
        - setDate(day) - sets the day of the month

        date.parse() - parses a date string and returns the number of milliseconds
        - parse will help us not only convert a date string to a date object but also to a timestamp and also do any equations with dates

        UTC methods are the same as the above methods but they return UTC time. What is UTC time?
        - UTC time is the time that is used by the world, it is the same time everywhere in the world
        
        find dat before 50 days from now
        const date = new Date();
        date.setDate(date.getDate() - 50);
        console.log(date); // 2020-12-02T23:00:00.000Z

        Date has autocorrect, so if you set the day to 40, it will automatically set it to the next month

    3. Time Methods:
        - getHours() - returns the hour 0 - 23
        - getMinutes() - returns the minutes 0 - 59
        - getSeconds() - returns the seconds 0 - 59
        - getMilliseconds() - returns the milliseconds 0 - 999
        - getTime() - returns the timestamp in milliseconds

        - setHours(hour, [min], [sec], [ms]) - sets the hour
        - setMinutes(min, [sec], [ms]) - sets the minutes
        - setSeconds(sec, [ms]) - sets the seconds
        - setMilliseconds(ms) - sets the milliseconds
        - setTime(ms) - sets the timestamp in milliseconds

        - Date.now() - returns the timestamp in milliseconds

        3600 seconds in an hour
        60 minutes in an hour
        1000 milliseconds in a second


Object Oriented javascript
    1. What is object literal:
        - key value pair data structure
        let obj = {
            name: 'john',
            age: 30
        }

        - add var to the object
        obj.address = '123 main st';

        - add function to object
        obj.greet = function(){
            console.log('hello');
        }

        
        obj can become a container for variables and functions then we pass it to a function.
        json is a string representation of an object literal
        change obj to json: JSON.stringify(obj)
        change json to obj: JSON.parse(json)

        dyanmic key:
        let key = 'name';
        obj[key] = 'john';

        let tv = 'tv'
        let obj = {
            [tv]: 'samsung'
        }

        how can we add read only properties to an object?
        - Object.defineProperty(obj, 'name', {
            value: 'john',
            writable: false
        })

        object shorthand:
        let name = 'john';
        let age = 30;
        let obj = {
            name,
            age
        }

        create clone of an object:
        let obj = {
            name: 'john',
            age: 30
        }
        let obj2 = Object.assign({}, obj);
        obj2.name = 'jane';
        console.log(obj2) // {name: 'jane', age: 30}

    2. What is This object:
        - this contains the current context
        - can have various values depending on where it is used
        

        console.log(this) // window object

        arrow function console.log(this) // window object
        const obj = {
            greet: () => {
                console.log(this) // window object
            }
        }

        normal function console.log(this) // undefined
        const obj = {
            greet: function(){
                console.log(this) // obj
            }
        }

    3. what is the purpose of call(), apply(), bind()
        function test(a ,b){
           
            console.log(this) // i want to assign the reference of this to obj
            console.log(a, b) // b is undefined
        }

        let obj ={
            a:5
        }

        call() first parameter is this, changes value of this.
        test.call(obj, 5, 6) // i want to assign the reference of this to obj; we dont need to pass obj as a parameter to test()

        function test(a, b, c){
            console.log(this) // i want to assign the reference of this to obj
           console.log(b, c) 
        }

        apply() can pass only 2 parameters, first parameter is this, second parameter is an array
        test.apply(obj, [5,6])

        bind() changes the this refernce and it returns a new function so that we can call it later
    
        const fe = test.bind(obj, 5, 6);
        fe() // 5, 6

        the purpose of all three is to change the value of this but just differ in parameters or execution

    4. classes
        class House{
            constructor(address, bedrooms, bathrooms){
                this.address = address;
                this.bedrooms = bedrooms;
                this.bathrooms = bathrooms;
            }

            getData(){
                console.log(this.address, this.bedrooms, this.bathrooms)
            }

            
        }

        let house1 = new House('address', 3, 2);

        create a static method
        class Static {
            static appVersion = '1.0.0'

            static test(){
                console.log('test')
                this.test2() // we can call other static methods directly
            }

            static test2(){
                console.log('test2')
            }
        }

        Static.test() // we dont need to create an instance of the class to call the static method
        Static.appVersion // we dont need to create an instance of the class to call the static property

        using class is just syntatic sugar for constructor functions

        //this is es5 syntax
        function house(windows){
            console.log('house')
            this.windows = windows;
        }

        let obj1 = new house(5);
        let obj1 = new house(10);

    5. Inheritance/subclassing, extending building class
        - inheritance in es6uses "extends" keyword 
        - we can use "super" keyword to call the parent constructor

        class Building {
            constructor(){
                this.land = 'land'
            }

            parentMethod(){
                console.log('parent method')
            }
        }

        class store extends Building {
            constructor(){
                super() // call the parent constructor and access parent props in child classess
                this.windows = 5;
            }

            childMethod(){
                super.parentMethod() // call the parent method
            }
        }

        - we can override the parent method in the child class if they are named the same we use super.methodName() to call the parent method
        - inheritance 
        - what is the super keyword used for? it's used to call the parent constructor and access parent props in child classess
        - how do we override the parent method in the child class if they are named the same we use super.methodName() to call the parent method

        - we can extend any class in javascript

    6. Destructuring Object Literals 
        - breaking data structure into data pieces or variables

        let obj = {
            name: 'john',
            age: 30
        }

        function hello({name, age}){
            console.log(name, age)
        }

        hello(obj) // john 30

        another way to destructure
        let obj1 = {
            test: 'one',
            test2: 'two'
        }

        let {test, test2} = obj1;
    
    7. Getters and Setters
        - getter are used to get the value of a property
        - setter are used to set the value of a property

        class Vehicle{

            #_model = '';
            
            get model(){
                return this.#_model;
            }

            set Model(v){
                if(v.length < 3) this.#_model = 'default';
                else this.#_model = v;
            }
        }

        const obj = new Vehicle();
        obj.model = 'SUV' // getter treats it as a property and setter treats it as a method
        the console will log setter executes

Map(), Set() weakMap() weakSet()
    1. Map() 

        let prod = new Map();
        prod.set('camp', 'camping');
        prod.set('hike', 'hiking');

        Set();
        let prod1 = new Set();
        prod1.set('iphone' , 'iphone');


        we can also iterate through map using values(), keys(), entries()

        for(let v of product.values()){
            console.log(v) // return values
        }

        for(let k of product.keys()){
            console.log(k) // returns keys
        }

        for(let e of product.entries()){
            console.log(e) // returns both key and value
        }

        - using destructuring
        for(let [key, value] of product.entries()){
            console.log(key, value) // returns both key and value
        }


        let newbobj = {
            name: 'john',
            age: 30
        }

        console.log(Object.entries(newbobj)) // returns an array of arrays

        let prodArr = new Map(Object.entries(newbobj));
        console.log(prodArr) // returns a map

        - convert map into simple object
        let obj = Object.fromEntries(prodArr);

        - map.has() checks if the key exists
        console.log(prod.has('camp')) // true

        - map.delete() deletes the key and value
        prod.delete('camp') // removes key

        - map.clear() removes all keys and values

        - use forEach to iterate through map but it has to finish the full iteration and cannot be stopped
        prod.forEach((value, key) => {
            console.log(value, key)
        })

        Map can have value to value mapping which doesn't happen in object literals
        Map has size property map.size()
        Map is iterable
        Map has methods like set(), get(), has(), delete(), clear(), forEach(), entries(), keys(), values()


    2. Set() - basically the same as map but can't have duplicate values, there is no key values just values
        let names = new Set();
        names.add('gianni')
        names.add('joe')
        names.add('joe') // will not add joe again because it already exists         

        set can iterate with for of
        for(let n of names){
            console.log(n);
        }

        and with forEach

        names.forEach((v) => {
            consol.log(v);
        });

        to delete and clear its the same as map
        names.delete('gianni')
        names.clear() // removes all values

    Map vs Set: is that Map has key:value pairs and Set has only values

    3. WeakMap() 
        - weakmap holds references weakly, so if GC happens it will remove the reference from memory
        - Map and Set hold the keys in a strong reference so if GC happens it will not remove the reference from memory

        - key in the weakmap are only objects
        - keys are weak 
        - because of weakkeys we can't iterate through weakmap or weakSet


        Garbage collection - when the browser is not using a variable anymore it will remove it from memory

        let newprod = new WeakMap();
        let obj = {

        }
        newprod.set(obj, 'iphone');
        console.log(newprod.get(obj)) // iphone

        what are the uses? to make sure there are no memory leaks


DOM & writable
    1. Understanding DOM
        - elements can be accessed in the DOM using document object
            - Window -> Document but they are 2 different objects
            - DOM is an interface accessible by programming languages. It is independent of the language and is a tree like structure
            - DOM API allows us to access the DOM
    
    2. Difference between Window and Document Object
        - Window is the global object in the browser, document is child object to window
        
        - setInterval() and setTimeout() are methods of window object but document is an object of window
        - document object has its own methods and properties as well like document.getElementById()
        - window also has innerHeight and innerWidth properties
        - BOM : browser object model and window object gives us access to the BOM. this can include screen, location, navigator, frames, history , XMLHttpRequest, etc

    3. How to handler timer based events:
        - these 2 methods are used to handle timer based events and are global methods
        - setTimeout() - executes a function once after a certain time (function, time)
        - setInterval() - executes a function repeatedly after a certain time (function, time)
        - clearInterval() - stops the execution of a function (function) we need to give the function running the setInterval and set it to a variable because we need to pass that variable to clearInterval()
    
    4. Event Bubbling and Event Capturing
        - event bubbling is when an event is triggered on a child element and it bubbles up to the parent element
        Dom Event Architecture:
            1. windows
            2. document
            3. html
            4. body
            5. div
            6. button

        - if we want to stop the event from bubbling up we can use event.stopPropagation(); 
        - also event.stopImmediatePropagation() which will stop the event from bubbling up and also stop the event from executing on the same element

        Event Capturing - when an event is triggered on a parent element and it bubbles down to the child element
        - we can use event capturing by passing true as the 3rd argument in addEventListener() method

    5 Event Delegation
        - in this example we are using a table and we want to add a click event to each td element
        event.target - returns the element that triggered the event
        event.target.tagName - returns the tag name of the element that triggered the event
        event.target.innerHTML - returns the innerHTML of the element that triggered the event

        - why is using bubbling / capturing useful? we can access deep level elements without having to add event listeners to each element

    6. Navigation through DOM

        - DOM will e the entry point to the document
        - getElementById we usually use this to get an element by its id. If there are child elements under the element, it will show the child elements
            document.getElementById is for the entire document
            element.getElementById won't work 
        - getElementsByTagName - returns a collection of elements with the given tag name
        - getElementsByClassName - returns a collection of elements with the given class name
        - getElementsByName - returns a collection of elements with the given name attribute

    7. getElementsBy<id, tags, class & name>()
        - getElementById: returns a single element with the given id
            - id:  id="myId"
            - tags: <div id="myId"></div>
            - class: <div class="myId"></div>
            - name: <div name="myId"></div>

        - getElementById is applied to document whereas the rest are applied to elements
    
    8. querySelector & querySelectorAll
        - querySelector: returns the first element that matches the given CSS selector
            const el = document.querySelector('.class');

        - querySelectorAll: returns a list of all elements that match the given CSS selector
        both are used to select elements using CSS selectors

    getElementBy has better Performance than querySelector

    9. Event Basics
        4 ways to write an event
            - inline
            - attribute
            - addEventListener
            - on<event> property

        inline: <button onclick="alert('hello')">Click Me</button>
        
        attribute: <button id="btn">Click Me</button>
            const btn = document.getElementById('btn');
            btn.onclick = function() {
                alert('hello');
            }

        bindingEventLater:
            const btn = document.getElementById('btn');
            btn.addEventListener('click', function() {
                alert('add event listener');
            }, true/false) 
        
        Event Object is a parent off all events

    10. MouseEvent 
        click rightCLick doubleClick: these are all mouse events
        <div id="myDiv" onCLick="eHandler('Click')" onContextMenu="eHandler('Right Click')" onDblClick="eHandler('Double Click')"></div>
        onContextManu=return false will prevent the right click menu from showing up


       e.ctrlKey - returns true if the ctrl key was pressed when the event was triggered
       e.metaKey - returns true if the meta key was pressed when the event was triggered. meta key is command on mac

       
    11. client x & y vs page x & y
        - client refers to window area vs page scrolled area
        - clientxy vs creen xy, screen refers to entire screen and client refers to window area

    12. Keyboard events
        - keydown 
        - keyup
        - keypress

        these all happen when a key is pressed, you can use e.key to get the key that was pressed or use functions to do something when a key is pressed

        this unlocks the ability to try combinations of keys and then execute code. 
        event.code returns the key code of the key that was pressed like shift left is shiftLeft

    13. Input element events:

        - onFocus: when the element is focused
        - onBlur: when the element is unfocused
        - onChange: when the value of the element is changed
        - onchange is heavily used in dropdown lists: <select onchange="eHandler(this.value)">
        - oninput is like a live change event, it will fire everytime the value changes

    14. input oncut, oncopy, onpaste
        - oncut: when the user cuts text
        - oncopy: when the user copies text
        - onpaste: when the user pastes text

        mainly used to stop or enable copy and paste behavior

Web Components:
    1. Intro:
        - component based architecture is a way of building applications where we break down the application into smaller components. 
        - less dev time as design is dived into smaller segments and pretty much most modern frameworks practices as well.

        basically create a new class and extend form HTMLElement base class, then we can use the custom element in the html.

    3. problem without shadow DOM
        - 

    4. html template, template.content.cloneNode(true) - creates a deep copy of the template
        - template tag is used to create a template that can be reused
        - template.content returns the content of the template
        - template.content.cloneNode(true) creates a deep copy of the template


asynchronous JS:

// a process that takes some time to execute is an async process

let data;
function fetchData(cb){
    //fake async process with setTimeout
    setTimeout(() =>{
        let data={
            name: 'john',
            age: 30
        }   
        cb(data);
    }, 2000) // instead of settimeout here is where we can make our fetch
}


console.log('starts here')
fetchData((data) =>{
    console.log(data);
    console.log('ends here')
});
//displayData(); // undefined, why? because the async process is not finished yet and we tried to log data before async call was finish

call back function is a function that is passed as a parameter to another function, it's justified for async process but 


example:
function cSqr(n, cb){
    setTimeout(() => {
        cb(n*n);
    }, 2000);
}
cSqr(2, (res) => {
    console.log(res);
})

promises and async await are better than callbacks now especially to avoid callback hell, i.e. pyramid of doom


what is a promise?
- when there are multi level jobs, promise object is invested to save us from callback hell. better way to write callback processes. refactor callback functions to promises
    Basic Syntax:
    let promise = new Promise((res, rej) =>{
        //statements
        resolve();
    })

    console.log(promise) // Promise {<pending>} - pending state, beginning of video for future reference.
    //multiple async processes
    Promise -> resolve -> then()
    Promise -> reject -> then()

    by default a function is not thenable, but we can make it thenable by returning a promise. 
    every then() should return a promise if we want to chain them

    finally() - used to execute code after the promise is settled
    what is chaining the promise? it's when we use then() to chain multiple promises together
    what is the status of promise by default? pending

Explain vs Promise.all() allSettled() & race() but now in days we use async await
    - promise.all() when we want to run multiple promises at the same time and wait for all of them to finish. all method is settled only with all resolved settled
    Promise.all([p1,p2,p3]).then((values) =>{
        //statements
    })

    - allSettled() - when we want to run multiple promises at the same time and wait for all of them to finish. all method is settled with all resolved and rejected settled

    - promise.race([]) - when we want to run multiple promises at the same time and wait for the first one to finish. all method is settled with the first resolved settled 
    race among promises easiest way to remember that.


Explain functionality of async/await?
    - async is used to make a function return a promise, easier way to deal with promises, promise was easier than callback but async/await is even easier
    
    //converted this function async to a promise, you also don't need to to return because async functions return a promise automatically
    const test = async (num) => {
        //await makes sure that the function waits for the promise to resolve before moving on, instead of then() we replace with await
        try{
            let result = await fetchData(num);
            console.log(result);
        }
        catch(e){
            console.log(e);
        }
    }

    const fn = test();
    console.log(fn) // undefined, why? because the function is not returning anything, by default that is what is returned without a return

    let result = await test(2);

    - best ways to handle errors with await is to use try catch block

    Ajax & XMLHttpRequest(XHR)

    for example dropdown country -> states 
    dropdown -> request -> server -> response. in the old days we used to use AJAX to do this, now we use fetch.
    XHR() - good to know but rarely used anymore
        example below:
        let request = new XMLHttpRequest(); (method, url, [async, user, password]) //false for async, true is default but will block rest of the code until the request is finished
        request.open('GET', 'https://jsonplaceholder.typicode.com/posts');
        request.responseType = 'json'; // automatically converted to json format, if we don't use this we will have to use JSON.parse()
        request.send(); // sends the request
        request.onload = function(){
            //console.log(request.status); 
            better way to deal with error:
            if(request.status === 200){
                console.log(request.response); // contains the body content of the response
            }else {
                console.log('error request');
            }
            
        }

        //timeout property : request.timeout = 1000; // 1000ms call should wait 1 second, if call takes longer than 1 second it will timeout
        request.ontimeout = function(){
            console.log('timeout');
        } // if the request takes longer than the timeout it will timeout and log

        request.onprogress = function(){
            console.log('loading');
        } // if the request is still loading it will log loading

        request.onreadystatechange = function(){
            // 0 - request not initialized, unset
            // 1 - opened
            // 2 - headers received
            // 3 - loading
            // 4 - done
            if(request.readyState === 4 && request.status === 200){
                console.log(request.response);
            }
        } // readyState 4 means the request is finished and status 200 means the request was successful

        request.abort()// aborts the request

        Angular used to use XHR but now uses fetch as well

        //there are other methods like onerror, onprogress, onreadystatechange, status
    
    !!!!Fetch API: 
        - better, faster, and more efficient way . XHR before es6, fetch is es6 and onwards

        const responsePromise = fetch('https://jsonplaceholder.typicode.com/posts'); (url, [optional object])
        to make a post request because not setting optional will default to get,

        const response = fetch('exampleurl', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body : json.stringify({name: 'john', age: 30}) // data
        })

        //there are other options like mode,cache, redirect. 
        async function fetchData(){
             
             try{
                const responsePromise = await fetch('https://jsonplaceholder.typicode.com/posts');
                //console.log(response.headers) // headers
                // console.log(response.headers.get('content-type')) // content type
                const response = await responsePromise.json(); //because it's a promise we need to convert data to json
                //const response = await responsePromise.text(); //if we want to convert to text
                // const response = await responsePromise.blob(); //if we want to convert to blob like images
                console.log(response);
             }catch(err){
                console.log(err);
             }
             
        }
        ok - true // concern here if the request was successful, show data
        status - 200 // these are important to access

        another way, since fetch is a promise we can use then() and catch() as well
        fetch('https://jsonplaceholder.typicode.com/posts')
        .then(res => {
            return res.json(); // returns a promise
        })
        .then(data => {
            console.log(data);
        })
        .catch((err) => {
            //can set error state here in react
            console.log(err);
        })

        //example post request to todos
        const todo = {
                title: 'foo',
                body: 'bar',
                userId: 1
            }
        fetch('https://jsonplaceholder.typicode.com/todos', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
                //other headers examples:
                // 'Content-Type': 'application/x-www-form-urlencoded',
                // 'Content-Type': 'multipart/form-data',
                // 'Content-Type': 'text/plain'
            },
            body: JSON.stringify(todo)
        })

        POST
        DELETE 
        PUT
        PATCH
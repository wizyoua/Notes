FreeCodeCamp - Data Structures - Computer Science Course for Beginners - https://www.youtube.com/watch?v=zg9ih6SVACc&ab_channel=freeCodeCamp.org

What is Big O notation: 
    - A way to basically score a data Structure based on 4 criteria
    - the most common functions you might want from a data Structure
     1. Accessing elements
     2. searching for an element
     3. Inserting an element
     4. Deleting an element

    - A time complexity equation works by inserting the size of the data-set as an integer N, and returning the number of operations
    that need to be conducted by the computer before the function can finish.

    - we always use worst case scenario when judging these data Structure

    - its called bigO notation because the syntax for the Time complexity equation includes a bigO and then a set of parentheses
        - the parentheses houses the function

    - We measure efficiency in # of operations performed because measuring by how long the function takes to run would be silly
        - Accessing
        - searching
        - inserting
        - Deleting
        - modeled by equation which takes in size of data-set and returns number of operations needed to be performed by the computer to complete that takes

    - A data Structure efficiency isn't the end all be all for deciding on which data Structure to implement. 

    6 most common time complexity equations - numbered below best to worst

    1. 0(1) 
        - no matter what the size of your data set is, the task will be completed in a single instruction.
        - graph of 0(1) remains constant at 1 - no matter the volume of data, the computer will complete task in single instruction

    2. 0(log n)
        - Still provides fast completion time.
        - gets more efficient as the size of the data set increases.
        -ex. Binary Search

    3. 0(n) 
        - the last of the decent equations
        - 

    4. 0(n log n)
        - the first which is relatively bad in terms of efficient.
        - slope increases as volume of data increases

    5. O(n^2)
        - very bad in efficiency
    
    6. O(2^n)
        - exponential in Structure

    Data Structures

    1. Array
        - most common data structure
        - fundamentally a list of similar values
        - can be used to store anything
        - store values of the same type
        - every item in the list of data is referred to as an element

        - there are also examples of parallel arrays
            - contain the same number of elements
            - have corresponding value in the same position

        - the arrays type
        - what type of info is stored or will be stored in the arrays
        - the size is a set integer that is fixed upon creation of the array
        - there are 2 ways to create an array in most languages
            - populate first
            - populate later   

        - to get info that is stored within the array, we use a numerical index. an integer which corresponds to an element within the array
        - an array within an array is known as 2 dimensional array

        - Array as a Data Structure Big O reference: 
            - Accessing array: O(1) - 
            - Searching array: O(n) - because most of time we are working with unsorted lists.
            - Inserting array: O(n) - because adding element into array requires you to shift every element thats after the index you are inserting to the right one space
            - Deleting array: O(n) - because removing element from array will shit everything to the left one space.
    
    2. ArrayList
        - the arrayList can be thought of as a growing array
        - why not always use arraylist?
            - 
        - arraylist is backed by array in memory
        - in python or js a array and arrayList are basically merged together, the example while learning this shows it in Java and C#
        - arrayList is an evolved array
        - arraylist belongs to class so it has pre built functions
        - type of functionality varies based on language
        - 6 common methods of ArrayList:
            - Add method
            - Remove method
            - Get method
            - Set method
            - Clear method
            - toArray method
        - Accessing : O(1)
        - Searching : O(n)
        - Inserting : O(n)
        - Deleting : O(n)

        Why not always use arrayList since it's more efficient:
            - arrayLists can only store objects

        Summary from this is not really applicable because in JS Pythong and PHP an array is basically an ArrayList 
    
    Random Access vs Sequential Data Structures
    - is a Sequential Access Data Structures
    - Do not provide O(1) Accessing
    - Can only be accessed in a particular order
    - Each element is dependent on the others
    - may only be obtained through those elements
    
    3. The Stack 
        - a Sequential access data structure in which we add elements and remove elements according to the LIFO Principle
        - Last In First Out
        - like grabbing a book 3 books below from the top, we can only access by removing the top 2 books
        - Common Stack methods
        
        - Push method 
            - pushes an object onto the top of the stack
            
        - Pop method
            - remove an element from the top of the stack

        - Peek method
            - Allows you to get the value at the top of the list without removing it

        - Contain method
            - used for searching through the Stack
        
        Time Complexity:

        Accessing : O(n)

        Searching : O(n)

        Inserting : O(1) since data only flows from single point, its pretty fast to access the immediate item same for deleting

        Deleting : O(1)

        - Stacks are used everywhere, both in code and real-world situations

        HEY!! a great example is recursion, since it is the process of function repeadetly calling themselves
        that means every time it runs, it keeps stacking the method runs, but then once it reaches base case, it 
        will pop the calls of. 

        real world situations are like undo/redo or backpage in browser. 

    4. The Queue
        - a Sequential access data structure which follows the FIFO methodology
            - FIrst in First Out
        - The location we add and remove elements in the Queue
            - add in the backed: tail
            - remove from the front: head
        
        Queue methods:
            - Enqueue
                - Add an element to the tail of the Queue
            
            - Dequeue 
                - Removes an element from the head of queue
            
            - Peek
                - returns the object thats at the forefront of the queue
            
            - Contains
                - returns wether or not the queue contains an object

        Time complexity: 
            Accessing : O(n)
            Searching : O(n)
            Inserting : O(n)
            Deleting : O(n)    

        Uses: 
            - used very often in programming for a variety of functions

    5. The Linkedlist
        - Sequential access linear data structure in  which every element is a seperate object called a Node which has 2 parts
            - The data
            - the reference(or pointer) which points to the next Node in the list
        
        Visualizartion


        Look how the starting node has data, and is null is no other node is added, but then if one is added the node 1 pointer points to 2
        and the newest node 2 has its data but then the pointer is null, and so on.
        
        (head node - arbitrary)
        Data:1
        Pointer: 2

        (Tail Node)
        Data:2
        Pointer:null
        
        - every node has information and a pointer

        How to add and remove from a linked list, not as simple as stack or queue.

        - Data can flow in and out from any point
            - Adding to the head of Linkedlist
            Make the new Node pointer point to the current Head of the Linkedlist

            - Removing from the Head of a Linkedlist
                - Set the Head Nodes pointer to null value, it will remove it. 
                - old head node regains its position

            - Adding a Node to the middle of a Linkedlist
                - Make the pointer of the new Node point to the Node after the location we want to insert at
                - Set the Node before the location we want to insert at to point towards the new Node

            - Removing a Node from the middle of the Linkedlist
                - Make the pointer of the Node previous to the one we're removing, to now point to the Node after the one we're removing.

            - Adding to the tail of a Linkedlist
                - Make the current tail point towards the new Node you want to add.
            
            - Removing from the Tail of a Linkedlist
                - Set the previous tail to point towards a null value instead of the current tail

        Time Complexity for Linked ListL:

        Accessing : O(n) - we can't get any element we want instantaneously

        Searching : O(n) - check a node and if not we want, we use the pointer to check next one, or null

        Inserting : O(1) - when inserting to head or tail 
                    O(n) - when inserting in middle of the list

        Deleting  : O(1) - when inserting to head or tail 
                    O(n) - when inserting in middle of the list

        Real world applications:
            - linkedlist can be used in the backing of other data Structures
            - can use it to make Stacks, Queue, etc. - really important in comp sci
            - Spotify queue
            - image viewing software
    
    6. 


    